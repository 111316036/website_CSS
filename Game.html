<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>劉采盈的俄羅斯方塊</title>
    <!-- 引入 Tailwind CSS 確保整體響應式佈局和現代感 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 使用 Inter 字體 */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212; 
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 1.5rem;
            padding-bottom: 1.5rem; 
            min-height: 100vh;
        }

        /* 遊戲核心區域 */
        #main-game-area {
            display: flex;
            gap: 1.25rem;
            max-width: 95%;
            margin: 0 auto;
            align-items: stretch; 
            min-width: 440px; 
        }

        /* 遊戲板樣式 */
        #game-board {
            border: 5px solid #00bcd4; 
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
            background-color: #1a1a1a; 
        }

        /* 側邊資訊欄 - 緊湊排列 */
        #sidebar {
            width: 140px; 
            display: flex;
            flex-direction: column;
            justify-content: space-between; 
        }

        /* 資訊卡片樣式 - 優化字體與間距 */
        .info-card {
            background-color: #242424; 
            padding: 0.35rem; 
            border-radius: 6px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            text-align: center;
            flex-shrink: 0; 
        }

        .info-card h2 {
            font-size: 0.7rem; /* 縮小字體 */
            font-weight: 700;
            margin-bottom: 0.1rem; 
            color: #00ffb7; 
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* 分數和等級顯示 */
        .data-display {
            font-size: 1.15rem; /* 縮小數據字體 */
            font-weight: 800;
            color: #ffff00; 
        }
        
        /* 主標題顏色與大小 */
        #sidebar h1 {
            color: #00ffb7; 
            font-size: 1rem; /* 縮小主標題 */
            line-height: 1.2; 
            margin-bottom: 0.4rem;
            font-weight: 900;
        }
        
        /* 預覽畫布 */
        canvas.preview-canvas {
            border: 1px solid #333; 
            background-color: #1a1a1a;
            margin: 0 auto;
            display: block;
            /* 讓 Canvas 顯示稍微縮小一點點 */
            transform: scale(0.9);
        }

        /* 遊戲按鈕 - 縮小尺寸 */
        .game-button {
            padding: 0.4rem 0.8rem;
            border-radius: 20px; 
            font-size: 0.75rem; /* 縮小按鈕文字 */
            font-weight: 700;
            transition: all 0.2s;
            cursor: pointer;
            text-transform: uppercase;
        }

        .game-button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .button-start { background-color: #38a169; color: white; }
        .button-pause { background-color: #d69e2e; color: #1a1a1a; }

        /* 操作說明卡片 */
        #instructions-card {
            max-width: 440px; 
            width: 90%; 
            margin-top: 1rem;
            padding: 0.6rem;
        }
        #instructions-card .grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.25rem 0.75rem;
            font-size: 0.7rem; /* 縮小說明文字 */
            color: #aaa;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            padding: 1.5rem;
            border-radius: 12px;
            text-align: center;
            z-index: 1000;
            border: 2px solid #ff6699; 
            display: none; 
            width: 240px;
        }

        @media (max-width: 768px) {
            #main-game-area { flex-direction: column; align-items: center; min-width: 100%; }
            #sidebar { width: 100%; flex-direction: row; flex-wrap: wrap; gap: 0.4rem; justify-content: center; }
            .info-card { flex: 0 1 auto; min-width: 80px; }
            #sidebar h1 { width: 100%; }
            #instructions-card { max-width: 100%; width: 95%; }
        }
    </style>
</head>
<body>

    <div id="game-wrapper" class="flex flex-col items-center">

        <div id="main-game-area">
            <!-- 遊戲主畫布 -->
            <canvas id="game-board"></canvas>

            <!-- 側邊資訊欄 -->
            <div id="sidebar">
                <h1 class="text-center">劉采盈 的<br>俄羅斯方塊</h1>

                <!-- 暫存區 -->
                <div class="info-card">
                    <h2>Hold</h2>
                    <canvas id="hold-canvas" class="preview-canvas"></canvas>
                </div>

                <div class="info-card">
                    <h2>Score</h2>
                    <div id="score-display" class="data-display">0</div>
                </div>

                <div class="info-card">
                    <h2>Level</h2>
                    <div id="level-display" class="data-display">1</div>
                </div>

                <div class="info-card">
                    <h2>Next</h2>
                    <canvas id="next-piece-canvas" class="preview-canvas"></canvas>
                </div>
                
                <div id="control-buttons" class="flex flex-col gap-2 w-full">
                    <button id="start-button" class="game-button button-start">Start</button>
                    <button id="pause-button" class="game-button button-pause" disabled>Pause (P)</button>
                </div>
            </div>
        </div>

        <!-- 底部操作說明 -->
        <div id="instructions-card" class="info-card text-left">
            <p class="font-bold mb-1 text-center text-[0.65rem] uppercase text-[#00ffb7] tracking-widest">Controls</p>
            <div class="grid">
                <p>← → : 移動</p>
                <p>↓ : 下落加速</p>
                <p>↑ / X : 旋轉方塊</p>
                <p>Space : 立即下落</p>
                <p>C / Shift : 暫存 (Hold)</p>
                <p>P : 暫停 (Pause)</p>
            </div>
        </div>
    </div>

    <div id="message-box" class="message-box">
        <h1 id="message-title" class="text-lg font-bold mb-2 text-pink-400">暫停</h1>
        <p id="message-text" class="text-sm mb-4">按下 'P' 繼續遊戲</p>
        <button id="message-button" class="game-button button-start w-full">繼續</button>
    </div>

    <script>
        const COLS = 12; 
        const ROWS = 20;
        const BLOCK_SIZE = 24; 
        const GAME_WIDTH = COLS * BLOCK_SIZE;
        const GAME_HEIGHT = ROWS * BLOCK_SIZE;

        const boardCanvas = document.getElementById('game-board');
        const boardCtx = boardCanvas.getContext('2d');
        boardCanvas.width = GAME_WIDTH;
        boardCanvas.height = GAME_HEIGHT;

        const nextCanvas = document.getElementById('next-piece-canvas');
        const nextCtx = nextCanvas.getContext('2d');
        nextCanvas.width = BLOCK_SIZE * 4; 
        nextCanvas.height = BLOCK_SIZE * 4;

        const holdCanvas = document.getElementById('hold-canvas');
        const holdCtx = holdCanvas.getContext('2d');
        holdCanvas.width = BLOCK_SIZE * 4;
        holdCanvas.height = BLOCK_SIZE * 4;

        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const messageBox = document.getElementById('message-box');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const messageButton = document.getElementById('message-button');

        const SHAPES = [
            [[0, 1], [1, 1], [2, 1], [3, 1]], // I
            [[0, 0], [0, 1], [1, 1], [2, 1]], // J
            [[2, 0], [0, 1], [1, 1], [2, 1]], // L
            [[0, 0], [1, 0], [0, 1], [1, 1]], // O
            [[1, 0], [2, 0], [0, 1], [1, 1]], // S
            [[1, 0], [0, 1], [1, 1], [2, 1]], // T
            [[0, 0], [1, 0], [1, 1], [2, 1]]  // Z
        ];

        const COLORS = [
            '#000000', '#00AEEF', '#0000CC', '#FF9900', '#FFD700', '#00CC00', '#9933CC', '#CC0000'
        ];

        let board, currentPiece, nextPieceShape, score, level, linesCleared, lastTime, dropCounter, dropInterval, isGameOver, isPaused, animationFrameId;
        let pieceBag = [];
        let heldPiece = null;
        let canHold = true;

        function refillBag() {
            pieceBag = [0, 1, 2, 3, 4, 5, 6];
            for (let i = pieceBag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieceBag[i], pieceBag[j]] = [pieceBag[j], pieceBag[i]];
            }
        }

        function createPiece(index = null) {
            if (index === null) {
                if (pieceBag.length === 0) refillBag();
                index = pieceBag.pop();
            }
            return {
                shape: JSON.parse(JSON.stringify(SHAPES[index])),
                colorIndex: index + 1,
                originalIndex: index,
                pos: { x: Math.floor(COLS / 2) - 2, y: 0 } 
            };
        }

        function holdPiece() {
            if (!canHold || isPaused || isGameOver) return;
            const currentIndex = currentPiece.originalIndex;
            if (heldPiece === null) {
                heldPiece = currentIndex;
                currentPiece = { ...nextPieceShape, pos: { x: Math.floor(COLS / 2) - 2, y: 0 } };
                nextPieceShape = createPiece();
                drawNextPiece();
            } else {
                const temp = heldPiece;
                heldPiece = currentIndex;
                currentPiece = createPiece(temp);
            }
            canHold = false;
            drawHoldPiece();
            draw();
        }

        function drawBlock(ctx, x, y, colorIndex, isGhost = false) {
            if (colorIndex === 0 && !isGhost) return;
            const px = x * BLOCK_SIZE;
            const py = y * BLOCK_SIZE;
            if (isGhost) {
                ctx.strokeStyle = '#555'; ctx.lineWidth = 1;
                ctx.strokeRect(px + 1, py + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
            } else {
                ctx.fillStyle = COLORS[colorIndex];
                ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
                ctx.strokeStyle = '#00000044'; ctx.lineWidth = 1;
                ctx.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
                ctx.fillStyle = '#FFFFFF33'; ctx.fillRect(px + 1, py + 1, BLOCK_SIZE - 2, 1);
            }
        }

        function drawBoard() {
            boardCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    drawBlock(boardCtx, x, y, board[y][x]);
                }
            }
        }

        function drawPiece(piece, ctx, offsetX = 0, offsetY = 0, isGhost = false) {
            piece.shape.forEach(row => {
                drawBlock(ctx, piece.pos.x + row[0] + offsetX, piece.pos.y + row[1] + offsetY, piece.colorIndex, isGhost);
            });
        }

        function calculateGhostPosition() {
            let ghostY = currentPiece.pos.y;
            while (isValidMove(currentPiece.shape, { x: currentPiece.pos.x, y: ghostY + 1 })) {
                ghostY++;
            }
            return ghostY;
        }

        function isValidMove(newShape, newPos) {
            for (let i = 0; i < newShape.length; i++) {
                const x = newPos.x + newShape[i][0];
                const y = newPos.y + newShape[i][1];
                if (x < 0 || x >= COLS || y >= ROWS) return false;
                if (y >= 0 && board[y][x] !== 0) return false;
            }
            return true;
        }

        function clearLines() {
            let cleared = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    cleared++;
                    board.splice(y, 1);
                    board.unshift(new Array(COLS).fill(0));
                    y++;
                }
            }
            if (cleared > 0) {
                linesCleared += cleared;
                const points = [0, 100, 300, 500, 800];
                score += points[cleared] * level;
                scoreDisplay.textContent = score;
                const newLevel = Math.floor(linesCleared / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    levelDisplay.textContent = level;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 80);
                }
            }
        }

        function rotatePiece() {
            if (currentPiece.colorIndex === 4) return;
            const rotated = currentPiece.shape.map(([x, y]) => {
                const dim = currentPiece.colorIndex === 1 ? 3 : 2;
                return [dim - y, x];
            });
            const kicks = [[0, 0], [-1, 0], [1, 0], [0, -1]];
            for (const [kx, ky] of kicks) {
                const newPos = { x: currentPiece.pos.x + kx, y: currentPiece.pos.y + ky };
                if (isValidMove(rotated, newPos)) {
                    currentPiece.shape = rotated;
                    currentPiece.pos = newPos;
                    return;
                }
            }
        }

        function dropPiece() {
            if (isValidMove(currentPiece.shape, { x: currentPiece.pos.x, y: currentPiece.pos.y + 1 })) {
                currentPiece.pos.y++;
                return true;
            } else {
                currentPiece.shape.forEach(([x, y]) => {
                    const bx = currentPiece.pos.x + x, by = currentPiece.pos.y + y;
                    if (by >= 0) board[by][bx] = currentPiece.colorIndex;
                });
                clearLines();
                canHold = true;
                currentPiece = { ...nextPieceShape, pos: { x: Math.floor(COLS / 2) - 2, y: 0 } };
                nextPieceShape = createPiece();
                drawNextPiece();
                if (!isValidMove(currentPiece.shape, currentPiece.pos)) gameOver();
                return false;
            }
        }

        function previewPiece(ctx, canvas, index) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (index === null) return;
            const shape = SHAPES[index];
            let minX = 4, minY = 4, maxX = 0, maxY = 0;
            shape.forEach(([x, y]) => {
                minX = Math.min(minX, x); minY = Math.min(minY, y);
                maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
            });
            const w = maxX - minX + 1, h = maxY - minY + 1;
            const ox = (canvas.width / BLOCK_SIZE - w) / 2 - minX;
            const oy = (canvas.height / BLOCK_SIZE - h) / 2 - minY;
            shape.forEach(([x, y]) => drawBlock(ctx, x + ox, y + oy, index + 1));
        }

        function drawNextPiece() { previewPiece(nextCtx, nextCanvas, nextPieceShape.originalIndex); }
        function drawHoldPiece() { previewPiece(holdCtx, holdCanvas, heldPiece); }

        function update(time = 0) {
            if (isGameOver || isPaused) return;
            const dt = time - lastTime;
            lastTime = time;
            dropCounter += dt;
            if (dropCounter > dropInterval) { dropPiece(); dropCounter = 0; }
            draw();
            animationFrameId = requestAnimationFrame(update);
        }

        function draw() {
            drawBoard();
            const gy = calculateGhostPosition();
            drawPiece({ ...currentPiece, pos: { ...currentPiece.pos, y: gy } }, boardCtx, 0, 0, true);
            drawPiece(currentPiece, boardCtx);
        }

        function startGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            messageBox.style.display = 'none';
            score = 0; level = 1; linesCleared = 0; dropInterval = 1000; isGameOver = false; isPaused = false;
            heldPiece = null; canHold = true;
            scoreDisplay.textContent = 0; levelDisplay.textContent = 1;
            board = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
            pieceBag = [];
            currentPiece = createPiece(); nextPieceShape = createPiece();
            drawNextPiece(); drawHoldPiece(); draw();
            pauseButton.disabled = false;
            lastTime = performance.now();
            update(lastTime);
        }

        function gameOver() {
            isGameOver = true;
            pauseButton.disabled = true;
            startButton.textContent = 'Retry';
            messageTitle.textContent = 'Game Over';
            messageText.textContent = `Score: ${score}`;
            messageBox.style.display = 'block';
        }

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;
            if (isPaused) {
                messageTitle.textContent = 'Paused';
                messageText.textContent = "Press 'P' to resume";
                messageBox.style.display = 'block';
            } else {
                messageBox.style.display = 'none';
                lastTime = performance.now();
                update(lastTime);
            }
        }

        startButton.addEventListener('click', () => {
            if (isGameOver || startButton.textContent === 'Start' || startButton.textContent === '開始遊戲') startGame();
            else togglePause();
        });
        pauseButton.addEventListener('click', togglePause);
        messageButton.addEventListener('click', togglePause);

        document.addEventListener('keydown', e => {
            if (isGameOver) { if (e.key === 'Enter') startGame(); return; }
            if (e.key.toLowerCase() === 'p') { togglePause(); return; }
            if (isPaused) return;
            switch (e.key) {
                case 'ArrowLeft': if (isValidMove(currentPiece.shape, { ...currentPiece.pos, x: currentPiece.pos.x - 1 })) currentPiece.pos.x--; break;
                case 'ArrowRight': if (isValidMove(currentPiece.shape, { ...currentPiece.pos, x: currentPiece.pos.x + 1 })) currentPiece.pos.x++; break;
                case 'ArrowDown': dropPiece(); break;
                case 'ArrowUp': case 'x': rotatePiece(); break;
                case ' ': e.preventDefault(); currentPiece.pos.y = calculateGhostPosition(); dropPiece(); break;
                case 'c': case 'C': case 'Shift': holdPiece(); break;
            }
            draw();
        });

        board = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
        drawBoard();
    </script>
</body>
</html>